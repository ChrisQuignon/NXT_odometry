<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="Anton"/><meta name="DCTERMS.issued" content="2009-05-21T20:43:00" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="Anton"/><meta name="DCTERMS.modified" content="2009-06-18T20:03:00" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; margin-bottom:0.139in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; }
	.P10 { font-size:10pt; margin-bottom:0in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; }
	.P11_borderStart { font-size:12pt; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-top:0in; border-left-style:none; border-right-style:none; border-top-style:none; padding-bottom:0in;  border-bottom-style:none; }
	.P11 { font-size:12pt; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; border-left-style:none; border-right-style:none; padding-bottom:0in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
	.P11_borderEnd { font-size:12pt; margin-bottom:0in; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-bottom:0.0138in; border-left-style:none; border-right-style:none; border-bottom-width:0.018cm; border-bottom-style:solid; border-bottom-color:#00000a; padding-top:0in;  border-top-style:none;}
	.P12 { font-size:12pt; margin:100%; margin-bottom:0in; margin-left:0.5in; margin-right:0in; margin-top:0in; text-indent:0in; font-family:Cambria; writing-mode:lr-tb; line-height:150%; text-align:justify ! important; }
	.P2 { font-size:12pt; margin-bottom:0.139in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; text-align:justify ! important; }
	.P3_borderStart { font-size:12pt; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-top:0in; border-left-style:none; border-right-style:none; border-top-style:none; padding-bottom:0in;  border-bottom-style:none; }
	.P3 { font-size:12pt; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; border-left-style:none; border-right-style:none; padding-bottom:0in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
	.P3_borderEnd { font-size:12pt; margin-bottom:0in; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-bottom:0.0138in; border-left-style:none; border-right-style:none; border-bottom-width:0.018cm; border-bottom-style:solid; border-bottom-color:#00000a; padding-top:0in;  border-top-style:none;}
	.P4_borderStart { font-size:12pt; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; text-align:center ! important; padding-left:0in; padding-right:0in; padding-top:0in; border-left-style:none; border-right-style:none; border-top-style:none; padding-bottom:0in;  border-bottom-style:none; }
	.P4 { font-size:12pt; font-family:Cambria; writing-mode:lr-tb; text-align:center ! important; padding-left:0in; padding-right:0in; border-left-style:none; border-right-style:none; padding-bottom:0in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
	.P4_borderEnd { font-size:12pt; margin-bottom:0in; font-family:Cambria; writing-mode:lr-tb; text-align:center ! important; padding-left:0in; padding-right:0in; padding-bottom:0.0138in; border-left-style:none; border-right-style:none; border-bottom-width:0.018cm; border-bottom-style:solid; border-bottom-color:#00000a; padding-top:0in;  border-top-style:none;}
	.P5 { font-size:12pt; margin-bottom:0in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; }
	.P6 { font-size:12pt; margin-bottom:0in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; line-height:150%; text-align:justify ! important; letter-spacing:0.0417in; }
	.P7 { font-size:12pt; margin-bottom:0in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; text-align:justify ! important; }
	.P8 { font-size:12pt; margin-bottom:0in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; text-align:justify ! important; }
	.P9 { font-size:12pt; margin-bottom:0in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; line-height:150%; text-align:justify ! important; }
	.T1 { font-family:Arial; font-size:9pt; }
	.T2 { font-family:Arial; letter-spacing:0.0693in; font-weight:bold; }
	.T4 { font-family:Arial; letter-spacing:0.0417in; }
	.T5 { font-family:Arial; letter-spacing:0.0417in; }
	.T6 { font-family:Arial; }
	.T7 { font-family:Arial; }
	.T8 { font-size:10pt; }
	<!-- ODF styles with no properties representable as CSS -->
	{ }
	</style></head><body dir="ltr" style="max-width:8.2681in;margin-top:0.9839in; margin-bottom:0.7874in; margin-left:0.9839in; margin-right:0.9839in; writing-mode:lr-tb; "><p class="P11_borderStart"><span class="T1">Roth Anton, Quignon Christoph</span></p><p class="P3"><span class="T1">Sommersemester 2009</span><span class="T2"> </span></p><p class="P4_borderEnd"><span class="T2">Project Report – Week 5</span></p><p class="P6"> </p><p class="P9"><span class="T4">Topic:</span></p><p class="P8"><span class="T7">Recoding the NXC-Code, to find a complete round was the topic of this week. It was necessary to recode this NXC-Code, because we used in the report of week 2 the “RotateMotorCount” command to detect the orientation of the NXC-Robot. In the report of week 4 it was mentioned that the “RotateMotorCount” was reset to zero after every step.  As a result of this it is no longer possible to check the “RotateMotorCount” to detect whether the NXC-Robot performs a full round or not.</span></p><p class="P1"> </p><p class="P9"><span class="T5">1. Dealing with reset of RotationMotorCount</span></p><p class="P8"><span class="T6">The idea of detecting a full round of the NXT-Robot with a reset of the </span><span class="T7">“RotateMotorCount” </span><span class="T6">is quite simple. The idea is to save the </span><span class="T7">“RotateMotorCount” </span><span class="T6">values before resetting them.  The first approach was to use the saved values in the arrays (degrees, direction), which were used in the report of week 4. The problem with this approach is that the NXC-Robot has to go through the whole array after each move. This ends in big costs for the NXC-Robot.</span></p><p class="P8"><span class="T6">The second approach was to save the </span><span class="T7">“RotateMotorCount” </span><span class="T6">value after each move into a separate variable “angleSum”. After each search-move the </span><span class="T7">“RotateMotorCount” </span><span class="T6">value is added to the “angleSum” variable. As mentioned in the report of week 4, the value of </span><span class="T7">“RotateMotorCount” </span><span class="T6">is not the same for both motors, so it is necessary to recalculate to the left or the right motor. This means that the focus of detecting a full round is based on one motor. Whenever the “angleSum” is 0 or 1035, a full round is reached. The value 1035 was figured out by turning the NXC-Robot 360 degrees and printing the </span><span class="T7">“RotateMotorCount” on the display of the Robot.</span></p><p class="P7"> </p><p class="P9"><span class="T5">2. Problems</span></p><p class="P8"><span class="T6">One problem of this week was to find the right place in the NXC-Code to safe the value of </span><span class="T7">“RotateMotorCount”</span><span class="T6">. The problem is that it is necessary to safe this value before using the command “OffEx(OUT_A, RESET_ALL)”. This command resets the </span><span class="T7">“RotateMotorCount” </span><span class="T6">value. So it is important to safe the value before stopping the robot. Meanwhile the robot is still searching for the path. But observations of the NXC-Robot are showing that this is a really small failure, which can be ignored. </span></p><p class="P8"><span class="T6">Another problem is the timing of the reset. It is necessary to give the NXC-Robot some time to reset the motors. If not, then it is possible that the NXC-Robot is doing some unpredictable moves. </span></p><p class="P2"> </p><p class="P2"> </p><p class="P2"> </p><p class="P6"> </p><p class="P6"> </p><p class="P6"> </p><p class="P6"> </p><p class="P6"/><p class="P9"><span class="T4">Attachment:</span></p><ol><li><p class="P12" style="margin-left:1.27cm;"><span style="display:block;float:left;min-width:0cm">1.</span><span class="T6">NXC – Code</span><span class="odfLiEnd"/> </p></li></ol><p class="P5"><span class="T8">int treshold = 40;  //light intensity boarder</span></p><p class="P5"><span class="T8">int speed = 40;     //general speed</span></p><p class="P5"><span class="T8">int searchWidth = 40;   //initial searchwith in degree</span></p><p class="P5"><span class="T8">int searchtime = 40;    //initial search time</span></p><p class="P5"><span class="T8">bool firstTurn;         //set to ture if first turn was found</span></p><p class="P5"><span class="T8">bool turnComplete;      //set to true if first full round was found</span></p><p class="P5"><span class="T8">int pointer=0;          //pointer to current array position</span></p><p class="P5"><span class="T8">long angleSum=0;        //current sum of all angles</span></p><p class="P5"><span class="T8">long degrees[200];      //Array of wheel degrees to drive</span></p><p class="P5"><span class="T8">int direction[200];     //0=left; 1=right; 2=forward</span></p><p class="P10"> </p><p class="P10"> </p><p class="P5"><span class="T8">sub makenoise(){              //sound output for testing</span></p><p class="P5"><span class="T8">  SoundPlayToneType sptArgs;</span></p><p class="P5"><span class="T8">  sptArgs.Frequency = 440;</span></p><p class="P5"><span class="T8">  sptArgs.Duration = 400;</span></p><p class="P5"><span class="T8">  sptArgs.Loop = false;</span></p><p class="P5"><span class="T8">  sptArgs.SoundLevel = 3;</span></p><p class="P5"><span class="T8">  SysSoundPlayTone(sptArgs);</span></p><p class="P5"><span class="T8">}</span></p><p class="P10"> </p><p class="P5"><span class="T8">sub makenoise2() {          //sound output for testing</span></p><p class="P5"><span class="T8">     SoundPlayToneType sptArgs;</span></p><p class="P5"><span class="T8">     sptArgs.Frequency = 200;</span></p><p class="P5"><span class="T8">     sptArgs.Duration = 800;</span></p><p class="P5"><span class="T8">     sptArgs.Loop = false;</span></p><p class="P5"><span class="T8">     sptArgs.SoundLevel = 3;</span></p><p class="P5"><span class="T8">     SysSoundPlayTone(sptArgs);</span></p><p class="P5"><span class="T8">}</span></p><p class="P10"> </p><p class="P5"><span class="T8">task drive(){</span></p><p class="P5"><span class="T8">      OnFwdSync(OUT_AB, speed, 0);</span></p><p class="P5"><span class="T8">}</span></p><p class="P10"> </p><p class="P5"><span class="T8">inline void halt() {              //inline due to frequently usage</span></p><p class="P5"><span class="T8">    OffEx(OUT_A, RESET_ALL);</span></p><p class="P5"><span class="T8">    OffEx(OUT_B, RESET_ALL);</span></p><p class="P5"><span class="T8">    Wait(15);                     //time to halt</span></p><p class="P5"><span class="T8">}</span></p><p class="P10"> </p><p class="P5"><span class="T8">sub toInitialR(long puffer){             //returns to center</span></p><p class="P5"><span class="T8">    while(MotorRotationCount(OUT_B) &lt;= puffer){</span></p><p class="P5"><span class="T8">       OnFwdSync(OUT_AB, speed, 100);   //right</span></p><p class="P5"><span class="T8">    }</span></p><p class="P5"><span class="T8">    halt();</span></p><p class="P5"><span class="T8">}</span></p><p class="P10"> </p><p class="P5"><span class="T8">sub toInitialL(long puffer){            //returns to center</span></p><p class="P5"><span class="T8">    while(MotorRotationCount(OUT_A) &lt;= (puffer * 10316 / 10000)){  //correction of the left wheel</span></p><p class="P5"><span class="T8">       OnFwdSync(OUT_AB, speed, -100);   //left</span></p><p class="P5"><span class="T8">    }</span></p><p class="P5"><span class="T8">    halt();</span></p><p class="P5"><span class="T8">}</span></p><p class="P10"> </p><p class="P10"/><p class="P5"><span class="T8">task search(){                  //searches for line</span></p><p class="P5"><span class="T8">     searchWidth = 40;</span></p><p class="P5"><span class="T8">     long puffer = 0;</span></p><p class="P5"><span class="T8">           OnFwd(OUT_AB, speed);</span></p><p class="P5"><span class="T8">           Wait(100);                 //correction of backwardsdrift</span></p><p class="P5"><span class="T8">           halt();</span></p><p class="P5"><span class="T8">     ResetRotationCount(OUT_AB);</span></p><p class="P5"><span class="T8">     while(true){</span></p><p class="P5"><span class="T8">           direction[pointer]=0;                    //left</span></p><p class="P5"><span class="T8">           while(MotorRotationCount(OUT_A) &lt;= searchWidth)</span></p><p class="P5"><span class="T8">           {</span></p><p class="P5"><span class="T8">           OnFwdSync(OUT_AB, speed, -100);          //left</span></p><p class="P5"><span class="T8">           }</span></p><p class="P5"><span class="T8">           puffer = MotorRotationCount(OUT_A);</span></p><p class="P5"><span class="T8">           halt();</span></p><p class="P5"><span class="T8">           //Back to begin search</span></p><p class="P5"><span class="T8">           ResetRotationCount(OUT_AB);</span></p><p class="P5"><span class="T8">           puffer = (puffer * 10316)/10000;         //correction of the left wheel</span></p><p class="P5"><span class="T8">           toInitialR(puffer);</span></p><p class="P5"><span class="T8">           ResetRotationCount(OUT_AB);</span></p><p class="P5"><span class="T8">           </span></p><p class="P5"><span class="T8">           searchWidth=searchWidth + 100;</span></p><p class="P5"><span class="T8">           direction[pointer]=1;                    //right</span></p><p class="P5"><span class="T8">           while(MotorRotationCount(OUT_B) &lt;= searchWidth)</span></p><p class="P5"><span class="T8">           {</span></p><p class="P5"><span class="T8">           OnFwdSync(OUT_AB, speed, 100);            //right</span></p><p class="P5"><span class="T8">           }</span></p><p class="P5"><span class="T8">           puffer = MotorRotationCount(OUT_B);</span></p><p class="P5"><span class="T8">           halt();</span></p><p class="P5"><span class="T8">           ResetRotationCount(OUT_AB);</span></p><p class="P5"><span class="T8">           puffer = (puffer * 10000)/10316;</span></p><p class="P5"><span class="T8">           toInitialL(puffer);</span></p><p class="P5"><span class="T8">           searchWidth=searchWidth + 100;</span></p><p class="P5"><span class="T8">           ResetRotationCount(OUT_AB);</span></p><p class="P5"><span class="T8">   }</span></p><p class="P5"><span class="T8">}</span></p><p class="P10"> </p><p class="P10"> </p><p class="P5"><span class="T8">sub linecheck(){                      //checks if ground is black/line</span></p><p class="P5"><span class="T8">   ResetRotationCount(OUT_AB);</span></p><p class="P5"><span class="T8">   Wait(50);</span></p><p class="P5"><span class="T8">   start drive;</span></p><p class="P5"><span class="T8">   while(true){</span></p><p class="P5"><span class="T8">        if(Sensor(IN_1) &gt; treshold){</span></p><p class="P5"><span class="T8">             StopTask(drive);</span></p><p class="P5"><span class="T8">             degrees[pointer]=MotorRotationCount(OUT_A);</span></p><p class="P5"><span class="T8">             halt();</span></p><p class="P5"><span class="T8">             direction[pointer] = 2;</span></p><p class="P5"><span class="T8">             pointer++;</span></p><p class="P5"><span class="T8">             break;</span></p><p class="P5"><span class="T8">        }</span></p><p class="P5"><span class="T8">    }</span></p><p class="P5"><span class="T8">}</span></p><p class="P10"> </p><p class="P10"> </p><p class="P5"><span class="T8">sub blankCheck(){                 //checks if ground is blank</span></p><p class="P5"><span class="T8">long lastSearchTime;</span></p><p class="P5"><span class="T8">long directionSearchTime;</span></p><p class="P5"><span class="T8">firstTurn= true;</span></p><p class="P5"><span class="T8">    while(true){</span></p><p class="P5"><span class="T8">        if(Sensor(IN_1) &lt;= treshold){</span></p><p class="P5"><span class="T8">          StopTask(search);</span></p><p class="P5"><span class="T8">          if(direction[pointer] == 0){      //left{</span></p><p class="P5"><span class="T8">            degrees[pointer]=MotorRotationCount(OUT_A);</span></p><p class="P5"><span class="T8">          }</span></p><p class="P5"><span class="T8">          else                             //right</span></p><p class="P5"><span class="T8">          {</span></p><p class="P5"><span class="T8">            degrees[pointer]=MotorRotationCount(OUT_B);</span></p><p class="P5"><span class="T8">          }</span></p><p class="P5"><span class="T8">          halt();</span></p><p class="P5"><span class="T8">          switch(direction[pointer]){</span></p><p class="P5"><span class="T8">             case 0:</span></p><p class="P5"><span class="T8">                 angleSum=(angleSum - (degrees[pointer] * 10316 / 10000));   //correction of the left wheel</span></p><p class="P5"><span class="T8">                 break;</span></p><p class="P5"><span class="T8">             case 1:</span></p><p class="P5"><span class="T8">                 angleSum=(angleSum + degrees[pointer]);   //right</span></p><p class="P5"><span class="T8">                 break;</span></p><p class="P5"><span class="T8">             case 2:</span></p><p class="P5"><span class="T8">                 break;</span></p><p class="P5"><span class="T8">             default:</span></p><p class="P5"><span class="T8">                 //Failure</span></p><p class="P5"><span class="T8">                 makenoise();</span></p><p class="P5"><span class="T8">                 break;</span></p><p class="P5"><span class="T8">          }</span></p><p class="P5"><span class="T8">          pointer++;</span></p><p class="P5"><span class="T8">          break;</span></p><p class="P5"><span class="T8">       }</span></p><p class="P5"><span class="T8">    }</span></p><p class="P5"><span class="T8">}</span></p><p class="P10"> </p><p class="P10"> </p><p class="P5"><span class="T8">task noline(){      //drives saved path without lightsensor</span></p><p class="P5"><span class="T8">     int i=0;</span></p><p class="P5"><span class="T8">     int x;</span></p><p class="P5"><span class="T8">     while (degrees[i] != 6000) {             //while not default initialisation</span></p><p class="P5"><span class="T8">           ResetRotationCount(OUT_AB);</span></p><p class="P5"><span class="T8">           Wait(100);</span></p><p class="P5"><span class="T8">           NumOut(0,LCD_LINE8, i);</span></p><p class="P5"><span class="T8">           x = direction[i];</span></p><p class="P5"><span class="T8">           switch(x){</span></p><p class="P5"><span class="T8">               case 0:</span></p><p class="P5"><span class="T8">                   while(MotorRotationCount(OUT_A) &lt;= (degrees[i] * 10316 / 10000)){  //correction of the left wheel</span></p><p class="P5"><span class="T8">                      OnFwdSync(OUT_AB, speed, -100);   //left</span></p><p class="P5"><span class="T8">                   }</span></p><p class="P5"><span class="T8">                   halt();</span></p><p class="P5"><span class="T8">                   break;</span></p><p class="P5"><span class="T8">               case 1:</span></p><p class="P5"><span class="T8">                   while(MotorRotationCount(OUT_B) &lt;= degrees[i]){</span></p><p class="P5"><span class="T8">                      OnFwdSync(OUT_AB, speed, 100);   //right</span></p><p class="P5"><span class="T8">                   }</span></p><p class="P5"><span class="T8">                   halt();</span></p><p class="P5"><span class="T8">                   break;</span></p><p class="P5"><span class="T8">               case 2:</span></p><p class="P5"><span class="T8">                   while(MotorRotationCount(OUT_A) &lt;= degrees[i]){</span></p><p class="P5"><span class="T8">                      OnFwdSync(OUT_AB, speed, 0);   //Forward</span></p><p class="P5"><span class="T8">                   }</span></p><p class="P5"><span class="T8">                   halt();</span></p><p class="P5"><span class="T8">                   break;</span></p><p class="P5"><span class="T8">               default:</span></p><p class="P5"><span class="T8">                   //Failure</span></p><p class="P5"><span class="T8">                   makenoise();</span></p><p class="P5"><span class="T8">                   break;</span></p><p class="P5"><span class="T8">           }</span></p><p class="P5"><span class="T8">           i = i + 1;</span></p><p class="P5"><span class="T8">     }</span></p><p class="P5"><span class="T8">}</span></p><p class="P10"> </p><p class="P10"> </p><p class="P5"><span class="T8">sub roundCheck(){  //checks if complete round was driven</span></p><p class="P5"><span class="T8">  if(firstTurn){</span></p><p class="P5"><span class="T8">    NumOut(0,LCD_LINE8,angleSum);       //Displays the angleSum</span></p><p class="P5"><span class="T8">    if ( pointer&gt;9 &amp;&amp; ( angleSum &gt; 900 || angleSum &lt; -900 || (angleSum &gt; -160 &amp;&amp; angleSum &lt; 160))) {</span></p><p class="P5"><span class="T8">       //Checks: some angles found and</span></p><p class="P5"><span class="T8">       //         more/less then 360° driven  or ~0° driven</span></p><p class="P5"><span class="T8">     makenoise2();</span></p><p class="P5"><span class="T8">    }</span></p><p class="P5"><span class="T8">  }</span></p><p class="P5"><span class="T8">}</span></p><p class="P10"> </p><p class="P5"><span class="T8">task main(){</span></p><p class="P5"><span class="T8">    ResetRotationCount(OUT_AB);</span></p><p class="P5"><span class="T8">    firstTurn = false;</span></p><p class="P5"><span class="T8">    turnComplete = false;</span></p><p class="P5"><span class="T8">    SetSensorLight(IN_1);</span></p><p class="P5"><span class="T8">          ArrayInit(degrees,6000,200);       //array initialisation with 6000 as default</span></p><p class="P5"><span class="T8">    while(!turnComplete){</span></p><p class="P5"><span class="T8">        linecheck();</span></p><p class="P5"><span class="T8">        StartTask(search);</span></p><p class="P5"><span class="T8">        blankCheck();</span></p><p class="P5"><span class="T8">        roundCheck();</span></p><p class="P5"><span class="T8">        Wait(100);</span></p><p class="P5"><span class="T8">    }</span></p><p class="P5"><span class="T8">        Wait(10000);</span></p><p class="P5"><span class="T8">        // start noline;</span></p><p class="P5"><span class="T8">}</span></p></body></html>
