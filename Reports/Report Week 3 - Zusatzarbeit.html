<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="Anton"/><meta name="DCTERMS.issued" content="2009-05-21T19:43:00" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="hetz"/><meta name="DCTERMS.modified" content="2009-06-12T07:23:00" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="
schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; margin-bottom:0.139in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; text-align:justify ! important; }
	.P10_borderStart { font-size:12pt; margin-top:0in; font-family:Arial; writing-mode:lr-tb; text-align:center ! important; padding-left:0in; padding-right:0in; padding-top:0in; border-left-style:none; border-right-style:none; border-top-style:none; letter-spacing:0.0693in; font-weight:bold; padding-bottom:0in;  border-bottom-style:none; }
	.P10 { font-size:12pt; font-family:Arial; writing-mode:lr-tb; text-align:center ! important; padding-left:0in; padding-right:0in; border-left-style:none; border-right-style:none; letter-spacing:0.0693in; font-weight:bold; padding-bottom:0in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
	.P10_borderEnd { font-size:12pt; margin-bottom:0in; font-family:Arial; writing-mode:lr-tb; text-align:center ! important; padding-left:0in; padding-right:0in; padding-bottom:0.0138in; border-left-style:none; border-right-style:none; border-bottom-width:0.018cm; border-bottom-style:solid; border-bottom-color:#000000; letter-spacing:0.0693in; font-weight:bold; padding-top:0in;  border-top-style:none;}
	.P11_borderStart { font-size:9pt; margin-top:0in; font-family:Arial; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-top:0in; border-left-style:none; border-right-style:none; border-top-style:none; padding-bottom:0in;  border-bottom-style:none; }
	.P11 { font-size:9pt; font-family:Arial; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; border-left-style:none; border-right-style:none; padding-bottom:0in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
	.P11_borderEnd { font-size:9pt; margin-bottom:0in; font-family:Arial; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-bottom:0.0138in; border-left-style:none; border-right-style:none; border-bottom-width:0.018cm; border-bottom-style:solid; border-bottom-color:#000000; padding-top:0in;  border-top-style:none;}
	.P12 { font-size:12pt; margin:100%; margin-bottom:0in; margin-left:0.5in; margin-right:0in; margin-top:0in; text-indent:0in; font-family:Arial; writing-mode:lr-tb; line-height:150%; text-align:justify ! important; }
	.P2 { font-size:12pt; margin-bottom:0.139in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; text-align:justify ! important; }
	.P3 { font-size:12pt; margin-bottom:0.139in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; text-align:justify ! important; letter-spacing:0.0417in; }
	.P4 { font-size:12pt; margin-bottom:0.139in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; }
	.P5 { font-size:12pt; margin-bottom:0.139in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; text-align:justify ! important; }
	.P6 { font-size:12pt; margin-bottom:0in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; line-height:150%; text-align:justify ! important; letter-spacing:0.0417in; }
	.P7 { font-size:10pt; margin-bottom:0in; margin-top:0in; font-family:Calibri; writing-mode:lr-tb; }
	.P8 { font-size:10pt; margin-bottom:0in; margin-top:0in; font-family:Calibri; writing-mode:lr-tb; }
	.P9_borderStart { font-size:12pt; margin-top:0in; font-family:Arial; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-top:0in; border-left-style:none; border-right-style:none; border-top-style:none; padding-bottom:0in;  border-bottom-style:none; }
	.P9 { font-size:12pt; font-family:Arial; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; border-left-style:none; border-right-style:none; padding-bottom:0in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
	.P9_borderEnd { font-size:12pt; margin-bottom:0in; font-family:Arial; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-bottom:0.0138in; border-left-style:none; border-right-style:none; border-bottom-width:0.018cm; border-bottom-style:solid; border-bottom-color:#000000; padding-top:0in;  border-top-style:none;}
	.T1 { font-size:9pt; }
	.T2 { letter-spacing:0.0693in; font-weight:bold; }
	<!-- ODF styles with no properties representable as CSS -->
	.T3 .T4 { }
	</style></head><body dir="ltr" style="max-width:8.2681in;margin-top:0.9839in; margin-bottom:0.7874in; margin-left:0.9839in; margin-right:0.9839in; writing-mode:lr-tb; "><p class="P11_borderStart">Roth Anton, Quignon Christophe</p><p class="P9"><span class="T1">Sommersemester 2009</span><span class="T2"> </span></p><p class="P10_borderEnd">Project Report – Week 3</p><p class="P6"> </p><p class="P3">Topic:</p><p class="P2">For the purpose to get 6 ECTS points we are attending an additional project. This project includes, following a black line along a closed way, recognizing a full turn and remembering the way and driving it without the black line again. Our third task in this project was to drive a gathered path.</p><p class="P4"> </p><p class="P3">Tests:</p><p class="P2">The critical point in this task is the correctness of the gathered information and the precision in repeating them. Therefore several test were set up and recorded. So far, there were no decision if the time or the motor rotation were more 
precise and reliable. The test results for both methods normalized over plenty iterations:</p><p class="P1">360 degree turn clockwise:</p><p class="P1"><span> wheel A </span><span> 1047 degree</span></p><p class="P1"><span> wheel B </span><span> -1184 degree</span></p><p class="P1">360 degree turn counterclockwise:</p><p class="P1"><span> wheel A</span><span> -1153 degree</span></p><p class="P1"><span> wheel B</span><span> 1078 degree</span></p><p class="P2">the precision when repeating the measured data were ~ 2 degree, which translates to an error of up to 0.55 percent.</p><p class="P2">The measured time an on 360 degree turn was independent of the turn direction and gave values between 2700ms and 3300ms, with a very high variance. The errors in repeating were unacceptable high, up to 8%.</p><p class="P5"> </p><p class="P3">Program changes:</p><p class="P2">Therefore the code to the previous were adjusted from time recording to motor rotation recording. The data storage structure changed from 3 arrays to 2 
arrays. The first one indicates the rotation on one wheel, and the second array indicates if the current rotations translates to a turn clockwise, counterclockwise or straight ahead. After 8 consecutive store points the robot had to be reset to the starting position and then starts to repeat the path.</p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P3">Outcome:</p><p class="P2">Despite the improved precision, the repeating of the waypoints gave no satisfying results. The first straight line was pretty accurate, and the following turn, if it was a big one was noticeable, but the imprecision rises with every waypoint. Several assertions can explain this behavior. First it is possible that the small line corrections mess up the data, second the error between the storing and the realization sums up, and third it could be possible that every change of the motor rotation and every reset of the motor rotation count distorts the accuracy. The concurrence of these errors are not predictable and 
have to be validated. It is also unclear if these errors sum up or negate each other, and if additional information and a combination of data can improve accuracy.</p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P5"> </p><p class="P6">Attachement:</p><ol><li><p class="P12" style="margin-left:1.27cm;"><span style="display:block;float:left;min-width:0cm">1.</span>NXC – Code<span class="odfLiEnd"/> </p></li></ol><p class="P7">int lightIntens = 40;     //light intensity boarder</p><p class="P7">int speed = 60;          //general speed</p><p class="P7">int searchtime = 40;    //initial search time</p><p class="P7">bool firstTurn;</p><p class="P7">long 
sumSearch = 0;</p><p class="P7">int arrayPointer=0;</p><p class="P7">int pointer=0;</p><p class="P7"> </p><p class="P7">long degrees[40];                  //degrees to drive</p><p class="P7">long direction[40];                 //0=left; 1=right; 2=forward</p><p class="P7"> </p><p class="P7">sub makenoise(){              //sound output for testing</p><p class="P8"><span class="T4">  </span><span class="T3">SoundPlayToneType sptArgs;</span></p><p class="P8"><span class="T4">  </span><span class="T3">sptArgs.Frequency = 440;</span></p><p class="P8"><span class="T4">  </span><span class="T3">sptArgs.Duration = 400;</span></p><p class="P8"><span class="T4">  </span><span class="T3">sptArgs.Loop = false;</span></p><p class="P8"><span class="T4">  </span><span class="T3">sptArgs.SoundLevel = 3;</span></p><p class="P8"><span class="T4">  </span><span class="T3">SysSoundPlayTone(sptArgs);</span></p><p class="P7">}</p><p class="P7"> </p><p class="P7">task drive(){</p><p class="P8"><span class="T4">      </span><span 
class="T3">OnFwdSync(OUT_AB, speed, 0);</span></p><p class="P7">}</p><p class="P7"> </p><p class="P7">task search(){</p><p class="P8"><span class="T4">     </span><span class="T3">searchtime = 40;</span></p><p class="P8"><span class="T4">     </span><span class="T3">//Because of Driving Forward Moves, which are recorded</span></p><p class="P7"><span>  OnFwd(OUT_AB, speed);</span></p><p class="P7"><span>  Wait(10);</span></p><p class="P7"><span>  Off(OUT_AB);</span></p><p class="P8"><span class="T4">     </span><span class="T3">ResetRotationCount(OUT_AB);</span></p><p class="P8"><span class="T4">     </span><span class="T3">while(true){</span></p><p class="P8"><span class="T4">           </span><span class="T3">Wait(100);</span></p><p class="P8"><span class="T4">           </span><span class="T3">direction[pointer]=0;</span></p><p class="P8"><span class="T4"> </span><span class="T3">                             OnFwdSync(OUT_AB, speed, 100); //left</span></p><p class="P8"><span class="T4">           </
span><span class="T3">Wait(searchtime);</span></p><p class="P8"><span class="T4">           </span><span class="T3">Off(OUT_AB);</span></p><p class="P7"> </p><p class="P8"><span class="T4">           </span><span class="T3">searchtime=searchtime + 200;</span></p><p class="P8"><span class="T4">           </span><span class="T3">Wait(100);</span></p><p class="P8"><span class="T4">           </span><span class="T3">direction[pointer]=1;</span></p><p class="P8"><span class="T4">           </span><span class="T3">OnFwdSync(OUT_AB, speed, -100);//right</span></p><p class="P8"><span class="T4">           </span><span class="T3">Wait(searchtime);</span></p><p class="P8"><span class="T4">           </span><span class="T3">Off(OUT_AB);</span></p><p class="P8"><span class="T4">           </span><span class="T3">searchtime=searchtime + 200;</span></p><p class="P8"><span class="T4">   </span><span class="T3">}</span></p><p class="P7">}</p><p class="P7"> </p><p class="P7">sub fullCircle(){</p><p class="P8"><span class="T4"
>    </span><span class="T3">//if(firstTurn){</span></p><p class="P8"><span class="T4">    </span><span class="T3">//   if(false)</span></p><p class="P8"><span class="T4">    </span><span class="T3">//       //both engines stay near the starting position</span></p><p class="P8"><span class="T4">    </span><span class="T3">//      {</span></p><p class="P8"><span class="T4">    </span><span class="T3">//        makenoise();</span></p><p class="P8"><span class="T4">    </span><span class="T3">//           Wait(2000);</span></p><p class="P8"><span class="T4">    </span><span class="T3">//     }</span></p><p class="P8"><span class="T4">    </span><span class="T3">//}</span></p><p class="P7"> </p><p class="P7">}<span> </span></p><p class="P7"/><p class="P7">sub linecheck(){</p><p class="P8"><span class="T4">   </span><span class="T3">fullCircle();</span></p><p class="P8"><span class="T4">   </span><span class="T3">//Because of Cycles, which are recorded</span></p><p class="P8"><span class="T4">   </span><span 
class="T3">ResetRotationCount(OUT_AB);</span></p><p class="P8"><span class="T4">   </span><span class="T3">start drive;</span></p><p class="P8"><span class="T4">   </span><span class="T3">SetSensorLight(IN_1);</span></p><p class="P8"><span class="T4">   </span><span class="T3">while(true)</span></p><p class="P8"><span class="T4">    </span><span class="T3">{</span></p><p class="P8"><span class="T4">        </span><span class="T3">if(Sensor(IN_1) &gt; lightIntens)</span></p><p class="P8"><span class="T4">        </span><span class="T3">{</span></p><p class="P8"><span class="T4">             </span><span class="T3">StopTask(drive);</span></p><p class="P8"><span class="T4">             </span><span class="T3">Off(OUT_AB);</span></p><p class="P8"><span class="T4">             </span><span class="T3">degrees[pointer]=MotorRotationCount(OUT_A);</span></p><p class="P8"><span class="T4">             </span><span class="T3">direction[pointer] = 2;</span></p><p class="P8"><span class="T4">             </span><span 
class="T3">pointer++;</span></p><p class="P8"><span class="T4">             </span><span class="T3">break;</span></p><p class="P8"><span class="T4">        </span><span class="T3">}</span></p><p class="P8"><span class="T4">    </span><span class="T3">}</span></p><p class="P7">}</p><p class="P7"> </p><p class="P7">sub blankcheck()</p><p class="P7">{</p><p class="P7">long lastSearchTime;</p><p class="P7">long directionSearchTime;</p><p class="P7">SetSensorLight(IN_1);</p><p class="P7">firstTurn= true;</p><p class="P8"><span class="T4">    </span><span class="T3">while(true)</span></p><p class="P8"><span class="T4">    </span><span class="T3">{</span></p><p class="P8"><span class="T4">        </span><span class="T3">if(Sensor(IN_1) &lt;= lightIntens)</span></p><p class="P8"><span class="T4">    </span><span class="T3">        {</span></p><p class="P8"><span class="T4">         </span><span class="T3">stop search;</span></p><p class="P8"><span class="T4">         </span><span class="T3">Off(OUT_AB);</span></p><p 
class="P8"><span class="T4">         </span><span class="T3">degrees[pointer]=MotorRotationCount(OUT_A);</span></p><p class="P8"><span class="T4">         </span><span class="T3">pointer++;</span></p><p class="P8"><span class="T4">         </span><span class="T3">break;</span></p><p class="P8"><span class="T4">      </span><span class="T3">}</span></p><p class="P8"><span class="T4">    </span><span class="T3">}</span></p><p class="P7">}</p><p class="P7"> </p><p class="P7">task noline() {</p><p class="P8"><span class="T4">     </span><span class="T3">int i=0;</span></p><p class="P8"><span class="T4">     </span><span class="T3">while (degrees[i]!=0) {</span></p><p class="P8"><span class="T4">           </span><span class="T3">ResetRotationCount(OUT_AB);</span></p><p class="P8"><span class="T4">           </span><span class="T3">Wait(100);</span></p><p class="P8"><span class="T4">           </span><span class="T3">switch(direction[i])</span></p><p class="P8"><span class="T4">           </span><span class="T3">{
</span></p><p class="P8"><span class="T4">               </span><span class="T3">case 0:</span></p><p class="P8"><span class="T4">                   </span><span class="T3">while(MotorRotationCount(OUT_A) != degrees[i])</span></p><p class="P8"><span class="T4">                   </span><span class="T3">{</span></p><p class="P8"><span class="T4">                      </span><span class="T3">OnFwdSync(OUT_AB, speed, 100);   //left</span></p><p class="P8"><span class="T4">                   </span><span class="T3">}</span></p><p class="P8"><span class="T4">                   </span><span class="T3">Off(OUT_AB);</span></p><p class="P8"><span class="T4">                   </span><span class="T3">i++;</span></p><p class="P8"><span class="T4">                   </span><span class="T3">break;</span></p><p class="P8"><span class="T4">               </span><span class="T3">case 1:</span></p><p class="P8"><span class="T4">                   </span><span class="T3">while(MotorRotationCount(OUT_A) != degrees[i])</span></
p><p class="P8"><span class="T4">                   </span><span class="T3">{</span></p><p class="P8"><span class="T4">                      </span><span class="T3">OnFwdSync(OUT_AB, speed, -100);   //right</span></p><p class="P8"><span class="T4">                   </span><span class="T3">}</span></p><p class="P8"><span class="T4">                   </span><span class="T3">Off(OUT_AB);</span></p><p class="P8"><span class="T4">                   </span><span class="T3">i++;</span></p><p class="P8"><span class="T4">                   </span><span class="T3">break;</span></p><p class="P8"><span class="T4">               </span><span class="T3">case 2:</span></p><p class="P8"><span class="T4">                   </span><span class="T3">while(MotorRotationCount(OUT_A) != degrees[i])</span></p><p class="P8"><span class="T4">                   </span><span class="T3">{</span></p><p class="P8"><span class="T4">                      </span><span class="T3">OnFwdSync(OUT_AB, speed, 0);   //Forward</span></p><p class="
P8"><span class="T4">                   </span><span class="T3">}</span></p><p class="P8"><span class="T4">                   </span><span class="T3">Off(OUT_AB);</span></p><p class="P8"><span class="T4">                   </span><span class="T3">i++;</span></p><p class="P8"><span class="T4">                   </span><span class="T3">break;</span></p><p class="P8"><span class="T4">               </span><span class="T3">default:</span></p><p class="P8"><span class="T4">                   </span><span class="T3">//Failure</span></p><p class="P8"><span class="T4">           </span><span class="T3">}</span></p><p class="P8"><span class="T4">     </span><span class="T3">}</span></p><p class="P7">}</p><p class="P7"> </p><p class="P7">task main()</p><p class="P7">{</p><p class="P8"><span class="T4">    </span><span class="T3">firstTurn = false;</span></p><p class="P8"><span class="T4">    </span><span class="T3">SetSensorLight(IN_1);</span></p><p class="P7"><span> ArrayInit(degrees,0,40);</span></p><p class="P8"
><span class="T4">    </span><span class="T3">while(pointer&lt;=8){                //task repeatline</span></p><p class="P8"><span class="T4">        </span><span class="T3">linecheck();</span></p><p class="P8"><span class="T4">        </span><span class="T3">start search;</span></p><p class="P8"><span class="T4">        </span><span class="T3">blankcheck();</span></p><p class="P8"><span class="T4">        </span><span class="T3">Wait(100);</span></p><p class="P8"><span class="T4">    </span><span class="T3">}</span></p><p class="P7"><span> Wait(10000);</span></p><p class="P7"><span> start noline;</span></p><p class="P7">}</p></body></html>
