<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by OpenOffice.org - see http://xml.openoffice.org/odf2xhtml for more info.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="Anton"/><meta name="DCTERMS.issued" content="2009-05-21T20:43:00" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="hetz"/><meta name="DCTERMS.modified" content="2009-06-12T06:47:00" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="
schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; margin-bottom:0.139in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; }
	.P10 { font-size:12pt; margin-bottom:0in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; line-height:150%; text-align:justify ! important; }
	.P11 { font-size:10pt; margin-bottom:0in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; }
	.P12 { font-size:10pt; margin-bottom:0in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; }
	.P13_borderStart { font-size:12pt; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-top:0in; border-left-style:none; border-right-style:none; border-top-style:none; padding-bottom:0in;  border-bottom-style:none; }
	.P13 { font-size:12pt; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; border-left-style:none; border-right-style:none; padding-bottom:0in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
	.P13_borderEnd { font-size:12pt; margin-bottom:0in; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-bottom:0.0138in; border-left-style:none; border-right-style:none; border-bottom-width:0.018cm; border-bottom-style:solid; border-bottom-color:#00000a; padding-top:0in;  border-top-style:none;}
	.P14 { font-size:12pt; margin:100%; margin-bottom:0in; margin-left:0.5in; margin-right:0in; margin-top:0in; text-indent:0in; font-family:Cambria; writing-mode:lr-tb; line-height:150%; text-align:justify ! important; }
	.P2 { font-size:12pt; margin-bottom:0.139in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; text-align:justify ! important; }
	.P3 { font-size:12pt; margin-bottom:0.139in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; text-align:justify ! important; }
	.P4_borderStart { font-size:12pt; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-top:0in; border-left-style:none; border-right-style:none; border-top-style:none; padding-bottom:0in;  border-bottom-style:none; }
	.P4 { font-size:12pt; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; border-left-style:none; border-right-style:none; padding-bottom:0in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
	.P4_borderEnd { font-size:12pt; margin-bottom:0in; font-family:Cambria; writing-mode:lr-tb; text-align:right ! important; padding-left:0in; padding-right:0in; padding-bottom:0.0138in; border-left-style:none; border-right-style:none; border-bottom-width:0.018cm; border-bottom-style:solid; border-bottom-color:#00000a; padding-top:0in;  border-top-style:none;}
	.P5_borderStart { font-size:12pt; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; text-align:center ! important; padding-left:0in; padding-right:0in; padding-top:0in; border-left-style:none; border-right-style:none; border-top-style:none; padding-bottom:0in;  border-bottom-style:none; }
	.P5 { font-size:12pt; font-family:Cambria; writing-mode:lr-tb; text-align:center ! important; padding-left:0in; padding-right:0in; border-left-style:none; border-right-style:none; padding-bottom:0in; padding-top:0in;  border-top-style:none; border-bottom-style:none; }
	.P5_borderEnd { font-size:12pt; margin-bottom:0in; font-family:Cambria; writing-mode:lr-tb; text-align:center ! important; padding-left:0in; padding-right:0in; padding-bottom:0.0138in; border-left-style:none; border-right-style:none; border-bottom-width:0.018cm; border-bottom-style:solid; border-bottom-color:#00000a; padding-top:0in;  border-top-style:none;}
	.P6 { font-size:12pt; margin-bottom:0in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; }
	.P7 { font-size:12pt; margin-bottom:0in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; line-height:150%; text-align:justify ! important; letter-spacing:0.0417in; }
	.P8 { font-size:12pt; margin-bottom:0in; margin-top:0in; font-family:Arial; writing-mode:lr-tb; text-align:justify ! important; }
	.P9 { font-size:12pt; margin-bottom:0in; margin-top:0in; font-family:Cambria; writing-mode:lr-tb; text-align:justify ! important; }
	.Table1 { width:5.466in; margin-left:-0.075in; writing-mode:lr-tb; }
	.Table1_A1 { padding-left:0.075in; padding-right:0.075in; padding-top:0in; padding-bottom:0in; border-style:none; }
	.Table1_C1 { padding-left:0.075in; padding-right:0.075in; padding-top:0in; padding-bottom:0in; border-left-style:none; border-right-width:0.0176cm; border-right-style:solid; border-right-color:#00000a; border-top-style:none; border-bottom-style:none; }
	.Table1_E1 { padding-left:0.075in; padding-right:0.075in; padding-top:0in; padding-bottom:0in; border-left-width:0.0176cm; border-left-style:solid; border-left-color:#00000a; border-right-style:none; border-top-style:none; border-bottom-style:none; }
	.Table1_A { width:1.8215in; }
	.Table1_B { width:0.5868in; }
	.Table1_C { width:1.2354in; }
	.Table1_D { width:0.2465in; }
	.Table1_E { width:1.5757in; }
	.T1 { font-family:Arial; font-size:9pt; }
	.T2 { font-family:Arial; letter-spacing:0.0693in; font-weight:bold; }
	.T3 { font-family:Arial; letter-spacing:0.0417in; }
	.T4 { font-family:Arial; letter-spacing:0.0417in; }
	.T5 { font-family:Arial; }
	.T6 { font-family:Arial; }
	.T8 { font-size:10pt; }
	.T9 { font-size:10pt; }
	<!-- ODF styles with no properties representable as CSS -->
	.Table1.1 .Table1.2 .Table1.3 { }
	</style></head><body dir="ltr" style="max-width:8.2681in;margin-top:0.9839in; margin-bottom:0.7874in; margin-left:0.9839in; margin-right:0.9839in; writing-mode:lr-tb; "><p class="P13_borderStart"><span class="T1">Roth Anton, Quignon Christophe</span></p><p class="P4"><span class="T1">Sommersemester 2009</span><span class="T2"> </span></p><p class="P5_borderEnd"><span class="T2">Project Report – Week 4</span></p><p class="P7"> </p><p class="P10"><span class="T3">Topic:</span></p><p class="P9"><span class="T6">This week’s topic was to fix the measure problems of the NXT-Robot. As mentioned in the report of week3, we figured out that the recorded turn ratio of both motors are not the same, even if both motors did drive exactly the same distance. Furthermore, The measure problem is even bigger when the wheels are driving backwards.    </span></p><p class="P1"> </p><p class="P10"><span class="T4">1. Find a constant in the measure failure</span></p><p class="P9"><span class="T5">In order to fix that measure 
problem, we had two ideas. One was to measure the degrees, as well as the time. The problem with this idea was the driven speed of the NXT-Robot-Motors. Every time the motors were started the NXT-Robot was either slower or faster. This behavior makes the time unpredictable and not useable. </span></p><p class="P9"><span class="T5"> </span></p><p class="P9"><span class="T5">Our second idea was to figure out coherence between the measured turn ratios of both wheels. For this purpose we thought about a way to test this behavior. So the robot should have turned three times 360 degrees to the left. Every 360 degrees we noted the turn ratio of the left wheel “B” and the right wheel “A”. We repeated this procedure for turning to the right. The following tables show the results:</span></p><p class="P8"> </p><p class="P9"><span class="T5">Turn Left:                                                         Turn Right:</span></p><p class="P8"> </p><table border="0" cellspacing="0" cellpadding="0" class="Table1"
><colgroup><col width="202"/><col width="65"/><col width="137"/><col width="27"/><col width="175"/></colgroup><tr class="Table11"><td colspan="2" style="text-align:left;width:1.8215in; " class="Table1_A1"><p class="P3"><span class="T5">           Wheel</span></p><p class="P3"><span class="T5">degrees</span></p></td><td colspan="2" style="text-align:left;width:1.2354in; " class="Table1_C1"><p class="P3"><span class="T5">A</span></p></td><td style="text-align:left;width:1.5757in; " class="Table1_E1"><p class="P3"><span class="T5">B</span></p></td></tr><tr class="Table12"><td colspan="2" style="text-align:left;width:1.8215in; " class="Table1_A1"><p class="P3"><span class="T5">360   degrees</span></p></td><td colspan="2" style="text-align:left;width:1.2354in; " class="Table1_A1"><p class="P3"><span class="T5">1046</span></p></td><td style="text-align:left;width:1.5757in; " class="Table1_A1"><p class="P3"><span class="T5">-1160</span></p></td></tr><tr class="Table13"><td colspan="2" style="text-align:left;width:1.
8215in; " class="Table1_A1"><p class="P3"><span class="T5">720   degrees </span></p></td><td colspan="2" style="text-align:left;width:1.2354in; " class="Table1_A1"><p class="P3"><span class="T5">2091</span></p></td><td style="text-align:left;width:1.5757in; " class="Table1_A1"><p class="P3"><span class="T5">-2301</span></p></td></tr><tr class="Table13"><td colspan="2" style="text-align:left;width:1.8215in; " class="Table1_A1"><p class="P3"><span class="T5">1080 degrees</span></p></td><td colspan="2" style="text-align:left;width:1.2354in; " class="Table1_A1"><p class="P3"><span class="T5">3139</span></p></td><td style="text-align:left;width:1.5757in; " class="Table1_A1"><p class="P3"><span class="T5">-3454</span></p></td></tr><tr class="Table11"><td style="text-align:left;width:1.8215in; " class="Table1_A1"><p class="P3"><span class="T5">           Wheel</span></p><p class="P3"><span class="T5">degrees</span></p></td><td colspan="2" style="text-align:left;width:0.5868in; " class="Table1_C1"><p class="P3"
><span class="T5">A</span></p></td><td colspan="2" style="text-align:left;width:0.2465in; " class="Table1_E1"><p class="P3"><span class="T5">B</span></p></td></tr><tr class="Table12"><td style="text-align:left;width:1.8215in; " class="Table1_A1"><p class="P3"><span class="T5">360   degrees</span></p></td><td colspan="2" style="text-align:left;width:0.5868in; " class="Table1_A1"><p class="P3"><span class="T5">-1138</span></p></td><td colspan="2" style="text-align:left;width:0.2465in; " class="Table1_A1"><p class="P3"><span class="T5">1084</span></p></td></tr><tr class="Table13"><td style="text-align:left;width:1.8215in; " class="Table1_A1"><p class="P3"><span class="T5">720   degrees </span></p></td><td colspan="2" style="text-align:left;width:0.5868in; " class="Table1_A1"><p class="P3"><span class="T5">-2245</span></p></td><td colspan="2" style="text-align:left;width:0.2465in; " class="Table1_A1"><p class="P3"><span class="T5">2166</span></p></td></tr><tr class="Table13"><td style="text-align:left;width:1.
8215in; " class="Table1_A1"><p class="P3"><span class="T5">1080 degrees</span></p></td><td colspan="2" style="text-align:left;width:0.5868in; " class="Table1_A1"><p class="P3"><span class="T5">-3344</span></p></td><td colspan="2" style="text-align:left;width:0.2465in; " class="Table1_A1"><p class="P3"><span class="T5">3247</span></p></td></tr></table><p class="P8"> </p><p class="P9"><span class="T5">On the basis of these tables it is possible to figure out the coherence between both wheels. The negative values are inaccurate, but the positive values are accurate in their produced failures. The three quotients of the positive numbers are nearly 1,035. With this knowledge the next task was to rewrite the NXC-Code in order to remember the driven way.</span></p><p class="P8"> </p><p class="P8"/><p class="P10"><span class="T4">2. Rewrite the NXC - Code</span></p><p class="P3"><span class="T5">The first task of this milestone was to produce an idea how to use this new knowledge. We decided to differ between a left 
and a right turn. If the robot drove to the left we saved the turn value of motor A, otherwise we saved the turn value of the right motor. The next problem was negative values. Every time the NXT-Robot searched the line, it drove alternating to the left and to the right. With these direction changes the turn ratios were unpredictable. In order to solve this problem the NXT-Robot had to drive back to its starting search point and the internal NXT-Robot rotation counter was reset to zero. After that, the robot continues searching to the opposite site. The main difficulty was getting back to the exact starting point. For this purpose we used the factor 1,035. With the use of the turnratio of one wheel, we calculated the needed turnration of the other wheel to go back to the starting point. This procedure was repeated as long as the line was found again.  </span></p><p class="P9"><span class="T5">In order to repeat this recorded move it was now necessary to differentiate between a left turn and a right turn with 
a “switch case” construct. It was also important to distinguish between the turnratio of motor “A” and the turnratio of motor “B”. After eight recorded steps the NXT-Robot repeats all steps.</span></p><p class="P2"> </p><p class="P2"> </p><p class="P3"><span class="T5"> </span></p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"/><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P7"> </p><p class="P10"><span class="T3">Attachement:</span></p><ol><li><p class="P14" style="margin-left:1.27cm;"><span style="display:block;float:left;min-width:0cm">1.</span><span class="T5">NXC – Code</span><span class="odfLiEnd"/> </p></li></ol><p class="
P11"> </p><p class="P6"><span class="T9">int lightIntens = 40;     //light intensity boarder</span></p><p class="P6"><span class="T9">int speed = 40;</span></p><p class="P6"><span class="T9">int degree = 80;        //general speed</span></p><p class="P6"><span class="T9">int searchtime = 40;    //initial search time</span></p><p class="P6"><span class="T9">bool firstTurn;</span></p><p class="P6"><span class="T9">int pointer=0;</span></p><p class="P12"> </p><p class="P6"><span class="T9">long degrees[40];                  //degrees to drive</span></p><p class="P12"> </p><p class="P6"><span class="T9">int direction[40];                 //0=left; 1=right; 2=forward</span></p><p class="P12"> </p><p class="P12"> </p><p class="P6"><span class="T9">sub makenoise(){              //sound output for testing</span></p><p class="P6"><span class="T9">  SoundPlayToneType sptArgs;</span></p><p class="P6"><span class="T9">  sptArgs.Frequency = 440;</span></p><p class="P6"><span class="T9">  sptArgs.Duration = 400;</span></
p><p class="P6"><span class="T9">  sptArgs.Loop = false;</span></p><p class="P6"><span class="T9">  sptArgs.SoundLevel = 3;</span></p><p class="P6"><span class="T9">  SysSoundPlayTone(sptArgs);</span></p><p class="P6"><span class="T9">}</span></p><p class="P12"> </p><p class="P6"><span class="T9">task drive(){</span></p><p class="P6"><span class="T9">      OnFwdSync(OUT_AB, speed, 0);</span></p><p class="P6"><span class="T9">}</span></p><p class="P12"> </p><p class="P6"><span class="T9">sub toInitialR(long puffer){</span></p><p class="P6"><span class="T9">    while(MotorRotationCount(OUT_B) &lt;= puffer)</span></p><p class="P6"><span class="T9">    {</span></p><p class="P6"><span class="T9">           OnFwdSync(OUT_AB, speed, 100);   //     right</span></p><p class="P6"><span class="T9">    }</span></p><p class="P6"><span class="T9">    OffEx(OUT_A, RESET_ALL);</span></p><p class="P6"><span class="T9">    OffEx(OUT_B, RESET_ALL);</span></p><p class="P12"> </p><p class="P6"><span class="T9">}</span></p><p 
class="P12"> </p><p class="P6"><span class="T9">sub toInitialL(long puffer){</span></p><p class="P6"><span class="T9">    while(MotorRotationCount(OUT_A) &lt;= puffer)</span></p><p class="P6"><span class="T9">    {</span></p><p class="P6"><span class="T9">           OnFwdSync(OUT_AB, speed, -100);   //     left</span></p><p class="P6"><span class="T9">    }</span></p><p class="P6"><span class="T9">    OffEx(OUT_A, RESET_ALL);</span></p><p class="P6"><span class="T9">    OffEx(OUT_B, RESET_ALL);</span></p><p class="P6"><span class="T9">}</span></p><p class="P12"> </p><p class="P6"><span class="T9">task search(){</span></p><p class="P6"><span class="T9">     degree = 80;</span></p><p class="P6"><span class="T9">     //Because of Driving Forward Moves, which are recorded</span></p><p class="P6"><span class="T9">     long puffer = 0;</span></p><p class="P6"><span class="T9">           OnFwd(OUT_AB, speed);</span></p><p class="P6"><span class="T9">           Wait(10);</span></p><p class="P6"><span class="T9">     
      OffEx(OUT_A, RESET_ALL);</span></p><p class="P6"><span class="T9">     OffEx(OUT_B, RESET_ALL);</span></p><p class="P6"><span class="T9">     Wait(10);</span></p><p class="P6"><span class="T9">     ResetRotationCount(OUT_AB);</span></p><p class="P6"><span class="T9">     while(true){</span></p><p class="P6"><span class="T9">           NumOut(100, LCD_LINE2, pointer);</span></p><p class="P6"><span class="T9">           direction[pointer]=0;</span></p><p class="P6"><span class="T9">           //LEFT</span></p><p class="P6"><span class="T9">           Wait(10);</span></p><p class="P6"><span class="T9">           while(MotorRotationCount(OUT_A) &lt;= degree)</span></p><p class="P6"><span class="T9">           {</span></p><p class="P6"><span class="T9">           OnFwdSync(OUT_AB, speed, -100);   //     left</span></p><p class="P6"><span class="T9">           }</span></p><p class="P6"><span class="T9">           puffer = MotorRotationCount(OUT_A);</span></p><p class="P6"><span class="T9">           OffEx(
OUT_A, RESET_ALL);</span></p><p class="P6"><span class="T9">           OffEx(OUT_B, RESET_ALL);</span></p><p class="P6"><span class="T9">           //Back to begin search</span></p><p class="P6"><span class="T9">           NumOut(0,LCD_LINE1,MotorRotationCount(OUT_A));</span></p><p class="P6"><span class="T9">           ResetRotationCount(OUT_AB);</span></p><p class="P6"><span class="T9">           puffer = (puffer * 1036)/1000;</span></p><p class="P6"><span class="T9">           NumOut(0,LCD_LINE2,puffer);</span></p><p class="P6"><span class="T9">           NumOut(0,LCD_LINE3,MotorRotationCount(OUT_A));</span></p><p class="P6"><span class="T9">           Wait(50);</span></p><p class="P6"><span class="T9">           toInitialR(puffer);</span></p><p class="P6"><span class="T9">           Wait(50);</span></p><p class="P6"><span class="T9">           ResetRotationCount(OUT_AB);</span></p><p class="P6"><span class="T9">           </span></p><p class="P6"><span class="T9">           degree=degree + 100;</span></
p><p class="P6"><span class="T9">           direction[pointer]=1;</span></p><p class="P6"><span class="T9">           while(MotorRotationCount(OUT_B) &lt;= degree)</span></p><p class="P6"><span class="T9">           {</span></p><p class="P6"><span class="T9">           OnFwdSync(OUT_AB, speed, 100);   //     right</span></p><p class="P6"><span class="T9">           }</span></p><p class="P6"><span class="T9">           puffer = MotorRotationCount(OUT_B);</span></p><p class="P6"><span class="T9">           OffEx(OUT_A, RESET_ALL);</span></p><p class="P6"><span class="T9">           OffEx(OUT_B, RESET_ALL);</span></p><p class="P6"><span class="T9">           NumOut(0,LCD_LINE1,MotorRotationCount(OUT_B));</span></p><p class="P6"><span class="T9">           ResetRotationCount(OUT_AB);</span></p><p class="P6"><span class="T9">           puffer = (puffer * 1000)/1036;</span></p><p class="P6"><span class="T9">           NumOut(0,LCD_LINE2,puffer);</span></p><p class="P6"><span class="T9">           NumOut(0,LCD_
LINE3,MotorRotationCount(OUT_B));</span></p><p class="P6"><span class="T9">           toInitialL(puffer);</span></p><p class="P6"><span class="T9">           Wait(50);</span></p><p class="P6"><span class="T9">           degree=degree + 100;</span></p><p class="P6"><span class="T9">           ResetRotationCount(OUT_AB);</span></p><p class="P6"><span class="T9">   }</span></p><p class="P6"><span class="T9">}</span></p><p class="P12"> </p><p class="P12"> </p><p class="P6"><span class="T9">sub fullCircle(){</span></p><p class="P6"><span class="T9">    //if(firstTurn){</span></p><p class="P6"><span class="T9">    //   if(false)</span></p><p class="P6"><span class="T9">    //       //both engines stay near the starting position</span></p><p class="P6"><span class="T9">    //      {</span></p><p class="P6"><span class="T9">    //        makenoise();</span></p><p class="P6"><span class="T9">    //           Wait(2000);</span></p><p class="P6"><span class="T9">    //     }</span></p><p class="P6"><span class="T9">    
//}</span></p><p class="P12"> </p><p class="P6"><span class="T9">}        </span></p><p class="P12"> </p><p class="P6"><span class="T9">sub linecheck(){</span></p><p class="P6"><span class="T9">   fullCircle();</span></p><p class="P6"><span class="T9">   //Because of Cycles, which are recorded</span></p><p class="P6"><span class="T9">   ResetRotationCount(OUT_AB);</span></p><p class="P6"><span class="T9">   Wait(50);</span></p><p class="P6"><span class="T9">   start drive;</span></p><p class="P6"><span class="T9">   while(true)</span></p><p class="P6"><span class="T9">    {</span></p><p class="P6"><span class="T9">        if(Sensor(IN_1) &gt; lightIntens)</span></p><p class="P6"><span class="T9">        {</span></p><p class="P6"><span class="T9">             StopTask(drive);</span></p><p class="P6"><span class="T9">             degrees[pointer]=MotorRotationCount(OUT_A);</span></p><p class="P6"><span class="T9">             OffEx(OUT_A, RESET_ALL);</span></p><p class="P6"><span class="T9">             OffEx(
OUT_B, RESET_ALL);</span></p><p class="P6"><span class="T9">             direction[pointer] = 2;</span></p><p class="P6"><span class="T9">             TextOut(0, LCD_LINE5, "Geradeaus: ");</span></p><p class="P6"><span class="T9">             NumOut(60, LCD_LINE5, pointer);</span></p><p class="P6"><span class="T9">             NumOut(70, LCD_LINE5,  direction[pointer]);</span></p><p class="P6"><span class="T9">             pointer++;</span></p><p class="P6"><span class="T9">             break;</span></p><p class="P6"><span class="T9">        }</span></p><p class="P6"><span class="T9">    }</span></p><p class="P6"><span class="T9">}</span></p><p class="P12"> </p><p class="P6"><span class="T9">sub blankcheck()</span></p><p class="P6"><span class="T9">{</span></p><p class="P6"><span class="T9">long lastSearchTime;</span></p><p class="P6"><span class="T9">long directionSearchTime;</span></p><p class="P6"><span class="T9">firstTurn= true;</span></p><p class="P6"><span class="T9">    while(true)</span></p><p 
class="P6"><span class="T9">    {</span></p><p class="P6"><span class="T9">        if(Sensor(IN_1) &lt;= lightIntens)</span></p><p class="P6"><span class="T9">            {</span></p><p class="P6"><span class="T9">         StopTask(search);</span></p><p class="P6"><span class="T9">         if(direction[pointer] == 0){  //left</span></p><p class="P6"><span class="T9">         degrees[pointer]=MotorRotationCount(OUT_A);</span></p><p class="P6"><span class="T9">         TextOut(0, LCD_LINE6, "LINKS: ");</span></p><p class="P6"><span class="T9">             NumOut(50, LCD_LINE6, pointer);</span></p><p class="P6"><span class="T9">             NumOut(70, LCD_LINE6,  direction[pointer]);</span></p><p class="P6"><span class="T9">         } else { //right</span></p><p class="P6"><span class="T9">         degrees[pointer]=MotorRotationCount(OUT_B);</span></p><p class="P6"><span class="T9">         TextOut(0, LCD_LINE6, "Rechts: ");</span></p><p class="P6"><span class="T9">         NumOut(50, LCD_LINE6, pointer);</
span></p><p class="P6"><span class="T9">         NumOut(70, LCD_LINE6,  direction[pointer]);</span></p><p class="P6"><span class="T9">         }</span></p><p class="P6"><span class="T9">         Wait(15);</span></p><p class="P6"><span class="T9">         OffEx(OUT_A, RESET_ALL);</span></p><p class="P6"><span class="T9">         OffEx(OUT_B, RESET_ALL);</span></p><p class="P6"><span class="T9">         makenoise();</span></p><p class="P6"><span class="T9">         Wait(15);</span></p><p class="P6"><span class="T9">         pointer++;</span></p><p class="P6"><span class="T9">         break;</span></p><p class="P6"><span class="T9">      }</span></p><p class="P6"><span class="T9">    }</span></p><p class="P6"><span class="T9">}</span></p><p class="P12"> </p><p class="P6"><span class="T9">task noline() {</span></p><p class="P6"><span class="T9">     int i=0;</span></p><p class="P6"><span class="T9">     int x;</span></p><p class="P6"><span class="T9">     while (i&lt;9) {</span></p><p class="P6"><span class="T9"
>           ResetRotationCount(OUT_AB);</span></p><p class="P6"><span class="T9">           NumOut(0,LCD_LINE7,direction[i]);</span></p><p class="P6"><span class="T9">           Wait(100);</span></p><p class="P6"><span class="T9">           NumOut(0,LCD_LINE8, i);</span></p><p class="P6"><span class="T9">           x = direction[i];</span></p><p class="P6"><span class="T9">           switch(x)</span></p><p class="P6"><span class="T9">           {</span></p><p class="P6"><span class="T9">               case 0:</span></p><p class="P6"><span class="T9">                   while(MotorRotationCount(OUT_A) &lt;= degrees[i])</span></p><p class="P6"><span class="T9">                   {</span></p><p class="P6"><span class="T9">                      OnFwdSync(OUT_AB, speed, 100);   //left</span></p><p class="P6"><span class="T9">                   }</span></p><p class="P6"><span class="T9">                   OffEx(OUT_A, RESET_ALL);</span></p><p class="P6"><span class="T9">                   OffEx(OUT_B, RESET_ALL);</
span></p><p class="P6"><span class="T9">                   break;</span></p><p class="P6"><span class="T9">               case 1:</span></p><p class="P6"><span class="T9">                   while(MotorRotationCount(OUT_B) &lt;= degrees[i])</span></p><p class="P6"><span class="T9">                   {</span></p><p class="P6"><span class="T9">                      OnFwdSync(OUT_AB, speed, -100);   //right</span></p><p class="P6"><span class="T9">                   }</span></p><p class="P6"><span class="T9">                   OffEx(OUT_A, RESET_ALL);</span></p><p class="P6"><span class="T9">                   OffEx(OUT_B, RESET_ALL);</span></p><p class="P6"><span class="T9">                   break;</span></p><p class="P6"><span class="T9">               case 2:</span></p><p class="P6"><span class="T9">                   while(MotorRotationCount(OUT_A) &lt;= degrees[i])</span></p><p class="P6"><span class="T9">                   {</span></p><p class="P6"><span class="T9">                      OnFwdSync(OUT_AB, 
speed, 0);   //Forward</span></p><p class="P6"><span class="T9">                   }</span></p><p class="P6"><span class="T9">                   OffEx(OUT_A, RESET_ALL);</span></p><p class="P6"><span class="T9">                   OffEx(OUT_B, RESET_ALL);</span></p><p class="P6"><span class="T9">                   break;</span></p><p class="P6"><span class="T9">               default:</span></p><p class="P6"><span class="T9">                   //Failure</span></p><p class="P6"><span class="T9">                   break;</span></p><p class="P6"><span class="T9">           }</span></p><p class="P6"><span class="T9">           i = i + 1;</span></p><p class="P6"><span class="T9">     }</span></p><p class="P6"><span class="T9">}</span></p><p class="P12"> </p><p class="P6"><span class="T9">task main()</span></p><p class="P6"><span class="T9">{</span></p><p class="P6"><span class="T9">    firstTurn = false;</span></p><p class="P6"><span class="T9">    SetSensorLight(IN_1);</span></p><p class="P6"><span class="T9">    
      ArrayInit(degrees,0,40);</span></p><p class="P6"><span class="T9">    while(pointer&lt;=8){                //task repeatline</span></p><p class="P6"><span class="T9">        linecheck();</span></p><p class="P6"><span class="T9">        StartTask(search);</span></p><p class="P6"><span class="T9">        blankcheck();</span></p><p class="P6"><span class="T9">        Wait(100);</span></p><p class="P6"><span class="T9">    </span><span class="T8">}</span></p><p class="P6"><span class="T8">        Wait(10000);</span></p><p class="P6"><span class="T8">        start noline;</span></p><p class="P6"><span class="T8">}</span></p></body></html>
